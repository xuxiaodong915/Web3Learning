# 第一阶段：基础能力建设

## 1.1 Solidity 核心语法精要

### 值类型与引用类型陷阱
```solidity
// 错误示例：存储位置混淆
function sum(uint[] memory arr) public pure returns (uint) {
    uint total;
    for(uint i=0; i<arr.length; i++){
        total += arr[i]; // 内存数组安全操作
    }
    return total;
}

// 正确引用类型操作
struct Holder {
    address account;
    uint balance;
}

function updateHolder(Holder storage self) internal {
    self.balance += 100; // 显式指定存储位置
}
```

### 继承与接口的模块化设计
```solidity
abstract contract MathUtil {
    function safeAdd(uint a, uint b) internal pure returns (uint) {
        return a + b;
    }
}

interface ITransferHook {
    function beforeTransfer(address from, address to, uint amount) external;
}

contract Token is MathUtil, ITransferHook {
    // 实现接口方法
    function beforeTransfer(address, address, uint) external override {}
}
```

### 安全的数学运算库实践
```solidity
// 使用内置安全检查（Solidity ^0.8.0）
function calculateReward(uint base, uint multiplier) public pure {
    require(multiplier > 0, "Invalid multiplier");
    uint result = base * multiplier; // 自动溢出检查
}

// 自定义安全库
library SafeMath {
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) return 0;
        uint256 c = a * b;
        require(c / a == b, "Math overflow");
        return c;
    }
}
```

## 1.2 ERC-20 标准深度解析

### 标准接口实现
```solidity
// 符合 ERC20 标准的核心实现
contract StandardToken {
    mapping(address => uint256) private _balances;
    
    function transfer(address to, uint256 amount) public virtual returns (bool) {
        _transfer(msg.sender, to, amount);
        return true;
    }

    // 实现其他标准方法...
}

// 扩展接口示例
interface IBurnable {
    function burn(uint256 amount) external;
    function burnFrom(address account, uint256 amount) external;
}
```

### 经济模型实现模式
```solidity
// 通缩模型实现
function _transfer(address sender, address recipient, uint256 amount) internal {
    uint256 burnAmount = amount * 2 / 100; // 2% 销毁
    uint256 actualAmount = amount - burnAmount;
    
    _balances[sender] -= amount;
    _balances[recipient] += actualAmount;
    _totalSupply -= burnAmount;
}

// 流动性奖励机制
function _mintLiquidityReward() internal {
    uint256 reward = totalSupply() * 5 / 1000; // 0.5% 流动性奖励
    _mint(lpPoolAddress, reward);
}

// 持币分红实现
function distributeDividends() public {
    uint256 contractBalance = address(this).balance;
    for (uint256 i = 0; i < shareholders.length; i++) {
        address shareholder = shareholders[i];
        uint256 share = balanceOf(shareholder) * contractBalance / totalSupply();
        payable(shareholder).transfer(share);
    }
}
```

## 最佳实践要点
1. 值类型操作始终使用最新Solidity版本的安全检查
2. 复杂逻辑通过接口实现模块解耦
3. 经济模型参数应设计可配置化
4. 所有数学运算必须包含边界检查
5. 存储布局遵循升级兼容性原则
