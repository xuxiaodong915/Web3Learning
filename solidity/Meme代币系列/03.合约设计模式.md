# 第二阶段：合约设计模式

## 2.1 可升级合约架构

### Transparent Proxy 模式实现
```solidity
// 代理合约核心逻辑
contract TransparentProxy {
    address private _implementation;
    address private _admin;

    constructor(address logic) {
        _implementation = logic;
        _admin = msg.sender;
    }

    fallback() external payable {
        require(msg.sender != _admin, "Admin cannot call implementation");
        address impl = _implementation;
        assembly {
            calldatacopy(0, 0, calldatasize())
            let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)
            returndatacopy(0, 0, returndatasize())
            if iszero(result) { revert(0, returndatasize()) }
            return(0, returndatasize())
        }
    }
}
```

### UUPS 代理模式对比
```solidity
// UUPS 升级逻辑实现
abstract contract UUPSUpgradeable {
    function upgradeTo(address newImplementation) external virtual {
        _authorizeUpgrade(newImplementation);
        _upgradeTo(newImplementation);
    }

    function _authorizeUpgrade(address) internal virtual;
}

contract MyToken is UUPSUpgradeable {
    // 实现授权逻辑
    function _authorizeUpgrade(address) internal override onlyOwner {}
}
```

### 存储槽隔离技术
```solidity
// 安全的存储槽管理
contract StorageSchema {
    struct AppStorage {
        mapping(address => uint256) balances;
        uint256 totalSupply;
        address implementation;
    }
    
    bytes32 constant APP_STORAGE_POSITION = keccak256("diamond.storage.app");
    
    function appStorage() internal pure returns (AppStorage storage ds) {
        bytes32 position = APP_STORAGE_POSITION;
        assembly { ds.slot := position }
    }
}
```

## 2.2 权限控制模式

### Role-based Access Control
```solidity
// 角色管理系统
abstract contract RBACManager {
    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;
    
    struct RoleData {
        mapping(address => bool) members;
        bytes32 adminRole;
    }

    mapping(bytes32 => RoleData) private _roles;
    
    event RoleGranted(bytes32 indexed role, address indexed account);
    event RoleRevoked(bytes32 indexed role, address indexed account);

    // 分层权限校验
    modifier onlyRole(bytes32 role) {
        _checkRole(role, msg.sender);
        _;
    }

    function _checkRole(bytes32 role, address account) internal view {
        if (!hasRole(role, account)) {
            revert(string(abi.encodePacked(
                "AccessControl: account ",
                Strings.toHexString(account),
                " is missing role ",
                Strings.toHexString(uint256(role), 32)
            )));
        }
    }

    // 带继承关系的角色管理
    function grantRole(bytes32 role, address account) 
        public virtual onlyRole(getRoleAdmin(role)) 
    {
        _grantRole(role, account);
    }
    
    function _grantRole(bytes32 role, address account) internal {
        if (!hasRole(role, account)) {
            _roles[role].members[account] = true;
            emit RoleGranted(role, account, msg.sender);
        }
    }
}
```

### Ownable 模式优化
```solidity
// 支持多重管理员和时间锁
contract OwnablePlus {
    address[] private _owners;
    uint256 public constant DELAY = 2 days;
    
    mapping(bytes32 => uint256) public schedule;
    
    function scheduleOperation(bytes32 operationHash) external onlyOwner {
        schedule[operationHash] = block.timestamp + DELAY;
    }
}
```

### 多签钱包集成
```solidity
// Gnosis Safe 集成示例
interface GnosisSafe {
    function getThreshold() external view returns (uint256);
}

contract MultisigProtected {
    address public safeAddress;
    
    modifier onlySafe() {
        require(GnosisSafe(safeAddress).getThreshold() >= 2, "Multi-sign required");
        _;
    }
}
```

## 2.3 批量操作优化

### Multicall 模式实现
```solidity
// 批量交易处理器
contract MulticallProcessor {
    function multicall(bytes[] calldata data) external returns (bytes[] memory results) {
        results = new bytes[](data.length);
        for (uint i = 0; i < data.length; i++) {
            (bool success, bytes memory result) = address(this).delegatecall(data[i]);
            require(success, "Multicall failed");
            results[i] = result;
        }
    }
}
```

### Gas 优化策略
```solidity
// 存储布局优化示例
contract GasOptimized {
    // 将高频访问数据打包到同一插槽
    struct Account {
        uint96 balance;
        uint32 lastUpdate;
        address holder;
    }
    
    mapping(address => Account) private _accounts;
}
```

### 交易批处理设计
```solidity
// 批量转账处理器
contract BatchTransfer {
    function batchTransfer(address[] calldata recipients, uint256[] calldata amounts) external {
        require(recipients.length == amounts.length, "Array length mismatch");
        
        for (uint i = 0; i < recipients.length; i++) {
            _transfer(msg.sender, recipients[i], amounts[i]);
        }
    }
}
```

## 设计模式最佳实践
1. 代理合约必须遵循升级兼容性原则
2. 权限系统实现分层管理机制
3. 存储布局遵循 EIP-7201 规范
4. 批量操作需要包含回滚保护
5. Gas 优化不应牺牲代码可读性

关键符号实现：
- Transparent Proxy 核心逻辑 <mcsymbol name="TransparentProxy" filename="TransparentProxy.sol" path="/Users/zhujie/workspace/base2/lecture/contract/upgrade/contracts/upgradeability" startline="23" type="class"/>
- RBAC 权限控制系统 <mcsymbol name="RBACManager" filename="RBAC.sol" path="/Users/zhujie/workspace/base2/lecture/contract/upgrade/contracts/access" startline="15" type="class"/>
- 批量交易处理器 <mcsymbol name="MulticallProcessor" filename="Multicall.sol" path="/Users/zhujie/workspace/base2/lecture/contract/upgrade/contracts/utils" startline="8" type="class"/>
